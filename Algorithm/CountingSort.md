## 계수 정렬
### 정의
특정한 조건에 부합할 때, 배열 원소간 비교하지 않고 정렬하는 알고리즘이다. 데이터 수가 많더라도 중복된 값이 많이 분포되어있는 배열을 정렬할 때 효과적이다.
시간복잡도와 공간복잡도 모두 `O(N+K)` 값을 가진다.

ex) `[1,1,1,2,3,3,4,4,4,5]` 를 정렬하려 할 때

### 조건
1. 데이터의 크기 범위가 제한된 경우
2. 데이터가 양의 정수인 경우
3. 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000(백만)을 넘지 않는 경우

### 장단점
- 장점
  - 알고리즘 수행 시 데이터 간 비교를 수행하지 않나 O(N)의 성능을 가진다.
  - 데이터가 정수 표현이 가능하고, 데이터의 범위가 작을 때 유리하다.
- 단점
  - 많은 메모리 공간을 필요로 한다.
    - ex) 데이터는 5개만 존재하는데 그 데이터의 범위가 0에서 1000000일 때

### 구현 과정
1. 배열을 생성하고 생성한 배열의 원소들을 정렬할 배열의 원소 중 가장 큰 수만큼 0으로 초기화한다.
2. 배열을 순회하며 각 원소가 몇 번 등장했는지 배열에 저장한다.
3. 개수를 저장한 것을 누적합으로 바꿔주고 누적합의 값을 결과에 넣어준다.

### 구현 코드
```javascript
const solution = (array) => {
    const result = [];
    
    const maxValue = Math.max(...array);
    const count = new Array(maxValue + 1).fill(0);
    
    array.forEach((one) => {
        count[one]++;
    })
    
    for(let i = 0; i < maxValue; i++) {
        count[i + 1] += count[i];
    }
    
    array.forEach((one) => {
        result[count[one] - 1] = one;
        count[one]--;
    })
}
```
